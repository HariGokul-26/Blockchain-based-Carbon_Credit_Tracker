# -*- coding: utf-8 -*-
"""Carbon_Credit_Tracker.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1yhh3ftsto8oYlLZ8XuoSEZ7EiGxxaTZ3
"""

import hashlib
import json
import time
from typing import List, Dict, Any


class Block:
    def __init__(self, index: int, previous_hash: str, data: Dict[str, Any], timestamp: float = None):
        self.index = index
        self.timestamp = timestamp or time.time()
        self.data = data  # {company_name, credits_earned, credits_used, note?, timestamp}
        self.previous_hash = previous_hash
        self.hash = self.calculate_hash()

    def calculate_hash(self) -> str:
        payload = {
            "index": self.index,
            "timestamp": self.timestamp,
            "data": self.data,
            "previous_hash": self.previous_hash,
        }
        s = json.dumps(payload, sort_keys=True, separators=(",", ":"))
        return hashlib.sha256(s.encode()).hexdigest()

    def __repr__(self):
        return f"Block(index={self.index}, hash={self.hash[:10]}..., prev={self.previous_hash[:10]}...)"


class CarbonCreditChain:
    def __init__(self):
        self.chain: List[Block] = [self._create_genesis_block()]

    def _create_genesis_block(self) -> Block:
        data = {
            "company_name": "GENESIS",
            "credits_earned": 0,
            "credits_used": 0,
            "timestamp": int(time.time()),
            "note": "Genesis block"
        }
        return Block(index=0, previous_hash="0" * 64, data=data)

    def latest_block(self) -> Block:
        return self.chain[-1]

    # --- Public API ---

    def earn_credits(self, company_name: str, amount: int, note: str = "") -> Block:
        if amount <= 0:
            raise ValueError("credits_earned must be positive")
        data = {
            "company_name": company_name,
            "credits_earned": int(amount),
            "credits_used": 0,
            "timestamp": int(time.time()),
            "note": note or "Earn"
        }
        return self._add_block(data)

    def use_credits(self, company_name: str, amount: int, note: str = "") -> Block:
        if amount <= 0:
            raise ValueError("credits_used must be positive")

        balance = self.get_company_balance(company_name)
        if amount > balance:
            raise ValueError(
                f"Insufficient credits for {company_name}: trying to use {amount}, available {balance}"
            )

        data = {
            "company_name": company_name,
            "credits_earned": 0,
            "credits_used": int(amount),
            "timestamp": int(time.time()),
            "note": note or "Use"
        }
        return self._add_block(data)

    def get_company_history(self, company_name: str) -> List[Dict[str, Any]]:
        history = []
        for b in self.chain[1:]:  # skip genesis
            d = b.data
            if d.get("company_name") == company_name:
                history.append({
                    "index": b.index,
                    "block_hash": b.hash,
                    "previous_hash": b.previous_hash,
                    "company_name": d["company_name"],
                    "credits_earned": d["credits_earned"],
                    "credits_used": d["credits_used"],
                    "timestamp": d["timestamp"],
                    "note": d.get("note", "")
                })
        return history

    def get_company_balance(self, company_name: str) -> int:
        earned = 0
        used = 0
        for b in self.chain[1:]:  # skip genesis
            d = b.data
            if d.get("company_name") == company_name:
                earned += int(d.get("credits_earned", 0))
                used += int(d.get("credits_used", 0))
        return earned - used

    def is_chain_valid(self) -> bool:
        # Validate hashes and links (immutability)
        for i in range(1, len(self.chain)):
            curr = self.chain[i]
            prev = self.chain[i - 1]
            if curr.hash != curr.calculate_hash():
                return False
            if curr.previous_hash != prev.hash:
                return False
        return True

    # --- Internal ---

    def _add_block(self, data: Dict[str, Any]) -> Block:
        prev = self.latest_block()
        block = Block(index=len(self.chain), previous_hash=prev.hash, data=data)
        self.chain.append(block)
        return block


# ---------------- DEMO ----------------
if __name__ == "__main__":
    ledger = CarbonCreditChain()

    # Company A earns and uses credits
    ledger.earn_credits("EcoAir Ltd", 1200, note="Wind farm issuance batch #WF-2025-08-01")
    ledger.use_credits("EcoAir Ltd", 300, note="Offset August domestic flights")
    ledger.earn_credits("EcoAir Ltd", 500, note="Solar PPA issuance #SP-77")
    ledger.use_credits("EcoAir Ltd", 900, note="Offset international cargo ops")

    # Company B earns credits
    ledger.earn_credits("GreenSteel Co", 2000, note="Blast furnace efficiency upgrade")

    # Attempting to overspend (will raise ValueError)
    try:
        ledger.use_credits("EcoAir Ltd", 700, note="Try to overspend")
    except ValueError as e:
        print("[BLOCKED - double spend protection]:", e)

    # Print history and balance for a company
    company = "EcoAir Ltd"
    history = ledger.get_company_history(company)
    balance = ledger.get_company_balance(company)

    print("\n=== Carbon Credit Usage History:", company, "===")
    for h in history:
        print(
            f"[Block #{h['index']}] {h['timestamp']} | "
            f"Earned: {h['credits_earned']:>4} | Used: {h['credits_used']:>4} | "
            f"Note: {h['note']} | Hash: {h['block_hash'][:12]}..."
        )

    print(f"\nCurrent Balance for {company}: {balance} credits")
    print("Chain valid?", ledger.is_chain_valid())